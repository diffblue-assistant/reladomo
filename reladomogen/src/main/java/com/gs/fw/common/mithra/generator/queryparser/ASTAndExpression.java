/*
 Copyright 2016 Goldman Sachs.
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing,
 software distributed under the License is distributed on an
 "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 KIND, either express or implied.  See the License for the
 specific language governing permissions and limitations
 under the License.
 */

/* Generated By:JJTree: Do not edit this line. ASTAndExpression.java */


package com.gs.fw.common.mithra.generator.queryparser;

import com.gs.fw.common.mithra.generator.MithraGeneratorException;
import com.gs.fw.common.mithra.generator.MithraObjectTypeWrapper;

import java.util.*;

public class ASTAndExpression extends SimpleNode
{

    private MithraObjectTypeWrapper owner;
    private boolean involvesThis = true;

    public ASTAndExpression(int id) {
        super(id);
    }

    public ASTAndExpression(MithraQL p, int id) {
        super(p, id);
    }

    public void checkConsistency(MithraObjectTypeWrapper owner, Map allObjects, List<String> errors)
    {
        //nothing to check, the contained ops will be checked one by one in the tree traversal anyway
        this.owner = owner;
    }

    /**
     * Accept the visitor. *
     */
    public Object jjtAccept(MithraQLVisitor visitor, Object data) {
        return visitor.visit(this, data);
    }

    public void addLeafLevelExpressionsToList(List list)
    {
        for(int i=0;i<children.length;i++)
        {
            SimpleNode s = (SimpleNode) children[i];
            s.addLeafLevelExpressionsToList(list);
        }
    }

    public List getChainedExpressions()
    {
        ArrayList result = new ArrayList();
        ArrayList operands = new ArrayList();
        this.addLeafLevelExpressionsToList(operands);
        SimpleNode firstExpression = this.getOwnerOperations(operands);
        result.add(firstExpression);
        if (operands.size() > 1)
        {
            HashSet firstSet = new HashSet();
            firstExpression.addDependentClassesToSet(firstSet);
            if (!this.involvesThis) firstSet.remove(owner);
            MithraObjectTypeWrapper[] array = new MithraObjectTypeWrapper[firstSet.size()];
            firstSet.toArray(array);
            if (array.length > 1) throw new MithraGeneratorException("multi-cross-join not yet implemented");
            ASTAndExpression and = new ASTAndExpression(MithraQLTreeConstants.JJTANDEXPRESSION);
            and.children = new SimpleNode[operands.size()];
            operands.toArray(and.children);
            and.owner = array[0];
            and.involvesThis = false;
            result.add(and);
        }
        else
        {
            result.add(operands.get(0));
        }
        return result;
    }

    public MithraObjectTypeWrapper getOwner()
    {
        return owner;
    }

    public void setOwner(MithraObjectTypeWrapper owner)
    {
        this.owner = owner;
    }

    public boolean isInvolvesThis()
    {
        return involvesThis;
    }

    public void setInvolvesThis(boolean involvesThis)
    {
        this.involvesThis = involvesThis;
    }

    protected SimpleNode getOwnerOperations(ArrayList operands)
    {
        ArrayList<LeafLevelExpression> ownerExpressions = new ArrayList<LeafLevelExpression>();
        for(int i=0;i<operands.size();)
        {
            LeafLevelExpression leafLevelExpression = (LeafLevelExpression) operands.get(i);
            if ((this.involvesThis && leafLevelExpression.involvesThis()) || (!this.involvesThis && leafLevelExpression.involvesClassAsNonThis(this.owner)))
            {
                ownerExpressions.add(leafLevelExpression);
                operands.remove(i);
            }
            else i++;
        }
        if (ownerExpressions.size() == 0) throw new MithraGeneratorException("relationship must depend on the current object");
        HashSet dependentSet = new HashSet();
        for(int i=0;i<ownerExpressions.size();i++)
        {
            SimpleNode leafLevelExpression = (SimpleNode) ownerExpressions.get(i);
            leafLevelExpression.addDependentClassesToSet(dependentSet);
        }
        if (!this.involvesThis) dependentSet.remove(owner);
        MithraObjectTypeWrapper[] array = new MithraObjectTypeWrapper[dependentSet.size()];
        dependentSet.toArray(array);
        if (array.length > 1) throw new MithraGeneratorException("multi-cross-join not yet implemented");
        for(int i=0;i<operands.size();)
        {
            LeafLevelExpression leafLevelExpression = (LeafLevelExpression) operands.get(i);
            if (leafLevelExpression.involvesOnlyThis(array[0]))
            {
                ownerExpressions.add(leafLevelExpression);
                operands.remove(i);
            }
            else i++;
        }
        if (ownerExpressions.size() > 1)
        {
            ASTAndExpression and = new ASTAndExpression(MithraQLTreeConstants.JJTANDEXPRESSION);
            and.children = new SimpleNode[ownerExpressions.size()];
            ownerExpressions.toArray(and.children);
            and.owner = owner;
            return and;
        }
        return (SimpleNode) ownerExpressions.get(0);
    }

    @Override
    public String constructFilterExpr()
    {
        ArrayList<String> list = new ArrayList(this.jjtGetNumChildren());
        for(int i=0;i<this.children.length;i++)
        {
            String child = ((SimpleNode)this.children[i]).constructFilterExpr();
            if (child != null && child.length() > 0)
            {
                list.add(child);
            }
        }
        if (list.isEmpty()) return "";
        if (list.size() == 1) return list.get(0);
        String expr = "("+list.get(0)+")";
        for(int i=1;i<list.size();i++)
        {
            expr += " && (" + list.get(i)+")";
        }
        return expr;
    }
}
